#File Generated by ALCOR 

function GENERATE_ALCOR_FILE(){
  # SEED_RANGE=$1
  # AUX_SEQ=$2
  # LOWEST_SIZE=$3
  # OUT_FILE=$4
#local OUT_FILE=""
read -p "Define the seed range: " SEED_RANGE
read -p "Define the number of auxiliary sequences used: " AUX_SEQ
#read -p "Define the increment factor to be used on sequence sizes " INCREMENT_FACTOR
#echo "The first $SEED_RANGE prime numbers  are: "
read -p "Define the lowest sequence size to be considered: " LOWEST_SIZE
read -p "Output file name: " OUT_FILE

declare -a seed_arr=()

length=0
rm $OUT_FILE


input="prime_numbers.seq"
while IFS= read -r line
do
 seed_arr+=($(echo $line))
 #length=$(($length+1))
 #echo $length
done < "$input"

#echo ${#seed_arr[@]}

 #j=$((${#seed_arr[@]}-1))
 j=$(($SEED_RANGE-1))

#for x in {1..$AUX_SEQ}
for((x=1;x<=$AUX_SEQ;x++ ))
do 
 if [ $j -eq 0 ];then
   #j=$((${#seed_arr[@]}-1))
   j=$(($SEED_RANGE-1))
   echo "j:"$j
 else
   j=$(($j-1))
fi 
 size=$(($LOWEST_SIZE*$x))
 #size=$(($size+$INCREMENT))
 #INCREMENT=$(($INCREMENT_FACTOR*$LOWEST_SIZE))
 #echo ${seed_arr[x]}
 seed=${seed_arr[$j]}
 #echo $seed
 
 #echo $size
 AlcoR simulation -rs $size:0:$seed:0:0:0 > sequence_$x.fasta
done

#for x in {0...$SEED_RANGE}
#for((x=0;x<${#seed_arr[@]}; x++ ))
#x=$((${#seed_arr[@]}-1))
#x=$(($SEED_RANGE-1))
#j=$(($x-1)) 
#size=$(($size+$INCREMENT))
for((x=0;x<$SEED_RANGE; x++ ))
do
 for y in {0..1}
 do
   #for z in {1..$AUX_SEQ}
   for((z=1;z<=$AUX_SEQ; z++ ))
   do
   #  if [ $x -eq 0 ];then
   #    #x=$((${#seed_arr[@]}-1))
   #    x=$(($SEED_RANGE-1))
   #   else
   #    x=$(($x-1))
   #   fi 
    #size=$(($LOWEST_SIZE*$z))
    size=$(($LOWEST_SIZE*$z))
    #echo $size
    #echo $z
    seed=${seed_arr[x]}
   #if [ $size -eq $LOWEST_SIZE ] 
    #then
    AlcoR simulation -fs 1:$size:0:$seed:0.0$y:0:0:sequence_$z.fasta >> $OUT_FILE
   #else
   # if [ $z -gt $valid_z ]
    # then
    #AlcoR simulation -fs 1:$size:0:${seed_arr[$j]}:0.0$y:0:0:sequence_$z.fasta >> $OUT_FILE
    #fi
   done
  done
 done
####    
sed -i '/^$/d' $OUT_FILE  
echo $OUT_FILE
}


function BUILD_CSV_HEADER_1(){
  COMPRESSOR="$1";
  IN_FILE="$2";

    IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

file="data_$COMPRESSOR-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
"PROGRAM","LEVEL","BYTES","C_BYTES","BPS_original","BPS_final","GAIN","C_TIME(s)","C_RAM(GB)","D_TIME(s)","D_MEM(GB)","DIFF","RUN"
.
wq
EOF
}


file="data_$COMPRESSOR-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
"$COMPRESSOR DATA",
.
wq
EOF
}

}


function BUILD_CSV_HEADER_2(){

COMPRESSOR="$1";
 IN_FILE="$2";

    IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME


file="data_$COMPRESSOR-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
"PROGRAM","LEVEL","PARTITION","BYTES","C_BYTES","BPS_original","BPS_final","GAIN","C_TIME(s)","C_RAM(GB)","D_TIME(s)","D_MEM(GB)","DIFF","RUN"
.
wq
EOF
}


file="data_$COMPRESSOR-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
"$COMPRESSOR DATA",
.
wq
EOF
}

}



function JARVIS3_COMPRESSION(){
  IN_FILE="$1";
  LEVEL="$2";
  PARTITION="$3";
  PARTITION_MB="$4"

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME
  # PARTITION_MB=$(cat $PARTITION | sed 's/MB//g')
  # if [[ $PARTITION == "1GB" ]] then
  #   PARTITION_MB="1000"
  # fi

  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -l $LEVEL --block $PARTITION --fasta -i $IN_FILE ; } 2>$IN_FILE_SHORT_NAME-$PARTITION_MB-l$LEVEL.txt
  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -l $LEVEL --block $PARTITION --fasta -i sort_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_$PARTITION_MB-l$LEVEL.txt
  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -l $LEVEL --block $PARTITION --fasta -i sort_fanalysis_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_fa_$PARTITION_MB-l$LEVEL.txt

  { ls $IN_FILE* -la -ltr | grep \.tar$ | awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-size_$PARTITION_MB-l$LEVEL.txt
  { ls sort_$IN_FILE* -la -ltr | grep \.tar$ | awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_size_$PARTITION_MB-l$LEVEL.txt
  { ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.tar$ | awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_size_$PARTITION_MB-l$LEVEL.txt

  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -d -l $LEVEL --fasta -i $IN_FILE.tar ;  } 2>$IN_FILE_SHORT_NAME-d_$PARTITION_MB-l$LEVEL.txt
  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -d -l $LEVEL --fasta -i sort_$IN_FILE.tar ;  } 2>$IN_FILE_SHORT_NAME-sort_d_$PARTITION_MB-l$LEVEL.txt
  { /bin/time -f "TIME\t%e\tMEM\t%M" ./JARVIS3.sh -d -l $LEVEL --fasta -i sort_fanalysis_$IN_FILE.tar ;  } 2>$IN_FILE_SHORT_NAME-sort_fa_d_$PARTITION_MB-l$LEVEL.txt

  { ls $IN_FILE* -la -ltr | grep \.tar.out$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-size_d_$PARTITION_MB-l$LEVEL.txt
  { ls sort_$IN_FILE* -la -ltr | grep \.tar.out$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_size_d_$PARTITION_MB-l$LEVEL.txt
  { ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.tar.out$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_size_d_$PARTITION_MB-l$LEVEL.txt

  rm *tar.out


}



function NAF_COMPRESSION() {
  IN_FILE="$1";
  LEVEL="$2";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

  echo "NAF Level" $LEVEL "compression"

{ /bin/time -f "TIME\t%e\tMEM\t%M"  ennaf --strict --temp-dir tmp/ --dna --level $LEVEL $IN_FILE ; } 2>$IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M"  ennaf --strict --temp-dir tmp/ --dna --level $LEVEL sort_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_naf_l$LEVEL.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M"  ennaf --strict --temp-dir tmp/ --dna --level $LEVEL sort_fanalysis_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_fa_naf_l$LEVEL.txt

{ ls $IN_FILE* -la -ltr | grep \.naf$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt
{ ls sort_$IN_FILE* -la -ltr | grep \.naf$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_naf_size_l$LEVEL.txt
{ ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.naf$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_naf_size_l$LEVEL.txt

echo "NAF Level" $LEVEL "decompression" 

{ /bin/time -f "TIME\t%e\tMEM\t%M" unnaf  $IN_FILE.naf -o $IN_FILE_SHORT_NAME-naf.fasta ; } 2>$IN_FILE_SHORT_NAME-unnaf_l$LEVEL.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M" unnaf  sort_$IN_FILE.naf -o sort_$IN_FILE_SHORT_NAME-naf.fasta ; } 2>$IN_FILE_SHORT_NAME-sort_unnaf_l$LEVEL.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M" unnaf  sort_fanalysis_$IN_FILE.naf -o sort_fanalysis_$IN_FILE_SHORT_NAME-naf.fasta ; } 2>$IN_FILE_SHORT_NAME-sort_fa_unnaf_l$LEVEL.txt

{ ls $IN_FILE_SHORT_NAME* -la -ltr | grep \naf.fasta$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-unnaf_size_l$LEVEL.txt
{ ls sort_$IN_FILE_SHORT_NAME* -la -ltr | grep \naf.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_unnaf_size_l$LEVEL.txt
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME* -la -ltr | grep \naf.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_unnaf_size_l$LEVEL.txt

rm *naf.fasta

}

function MBGC_COMPRESSION() {
  IN_FILE="$1";
  LEVEL="$2";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

rm $IN_FILE_SHORT_NAME.mbgc
rm sort_$IN_FILE_SHORT_NAME.mbgc
rm sort_fanalysis_$IN_FILE_SHORT_NAME.mbgc

{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -c=$LEVEL -i $IN_FILE $IN_FILE_SHORT_NAME.mbgc ; } 2>$IN_FILE_SHORT_NAME-mbgc_l$LEVEL.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -c=$LEVEL -i sort_$IN_FILE sort_$IN_FILE_SHORT_NAME.mbgc ; } 2>$IN_FILE_SHORT_NAME-sort_mbgc_l$LEVEL.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -c=$LEVEL -i sort_fanalysis_$IN_FILE sort_fanalysis_$IN_FILE_SHORT_NAME.mbgc ; } 2>$IN_FILE_SHORT_NAME-sort_fa_mbgc_l$LEVEL.txt

{ ls $IN_FILE_SHORT_NAME* -la -ltr | grep \.mbgc$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-mbgc_size_l$LEVEL.txt
{ ls sort_$IN_FILE_SHORT_NAME* -la -ltr | grep \.mbgc$ |awk '{print $5;}'; } >  $IN_FILE_SHORT_NAME-sort_mbgc_size_l$LEVEL.txt
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME* -la -ltr | grep \.mbgc$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_mbgc_size_l$LEVEL.txt

{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -d $IN_FILE_SHORT_NAME.mbgc mbgc_decompress_l$LEVEL ; } 2>$IN_FILE_SHORT_NAME-mbgc_d_l$LEVEL.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -d sort_$IN_FILE_SHORT_NAME.mbgc sort_mbgc_decompress_l$LEVEL ; } 2>$IN_FILE_SHORT_NAME-sort_mbgc_d_l$LEVEL.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" mbgc -d sort_fanalysis_$IN_FILE_SHORT_NAME.mbgc sort_fanalysis_mbgc_decompress_l$LEVEL ; } 2>$IN_FILE_SHORT_NAME-sort_fa_mbgc_d_l$LEVEL.txt 

#  mbgc -d $IN_FILE_SHORT_NAME.mbgc mbgc_decompress
#  mv mbgc_decompress/$IN_FILE_SHORT_NAME.fasta $IN_FILE_SHORT_NAME-mbgc.fasta 
#  mv sort_mbgc_decompress/sort_$IN_FILE_SHORT_NAME.fasta sort_$IN_FILE_SHORT_NAME-mbgc.fasta 
#  mv sort_fanalysis_mbgc_decompress/sort_fanalysis_$IN_FILE_SHORT_NAME.fasta sort_fanalysis_$IN_FILE_SHORT_NAME-mbgc.fasta 

cd mbgc_decompress_l$LEVEL
{ ls $IN_FILE_SHORT_NAME* -la -ltr | grep \.fasta$ |awk '{print $5;}' ; } >  $IN_FILE_SHORT_NAME-mbgc_d_size_l$LEVEL.txt
cd ..
mv mbgc_decompress_l$LEVEL/$IN_FILE_SHORT_NAME-mbgc_d_size_l$LEVEL.txt $IN_FILE_SHORT_NAME-mbgc_d_size_l$LEVEL.txt
cd sort_mbgc_decompress_l$LEVEL
{ ls sort_$IN_FILE_SHORT_NAME* -la -ltr | grep \fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_mbgc_d_size_l$LEVEL.txt
cd ..
mv sort_mbgc_decompress_l$LEVEL/$IN_FILE_SHORT_NAME-sort_mbgc_d_size_l$LEVEL.txt $IN_FILE_SHORT_NAME-sort_mbgc_d_size_l$LEVEL.txt
cd sort_fanalysis_mbgc_decompress_l$LEVEL
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME* -la -ltr | grep \fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_mbgc_d_size_l$LEVEL.txt
cd ..
mv sort_fanalysis_mbgc_decompress_l$LEVEL/$IN_FILE_SHORT_NAME-sort_fa_mbgc_d_size_l$LEVEL.txt $IN_FILE_SHORT_NAME-sort_fa_mbgc_d_size_l$LEVEL.txt

rm -d mbgc_decompress_*
rm -d sort_mbgc_decompress_*
rm -d sort_fanalysis_mbgc_decompress_*



  
}

function MFCOMPRESS_COMPRESSION(){
  IN_FILE="$1";
  LEVEL="$2";
  PARTITION="$3";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME


{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressC -v -$LEVEL -p $PARTITION -t 8 $IN_FILE ; } 2>$IN_FILE_SHORT_NAME-mfc_l$LEVEL-p$PARTITION-t8.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressC -v -$LEVEL -p $PARTITION -t 8 sort_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_mfc_l$LEVEL-p$PARTITION-t8.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressC -v -$LEVEL -p $PARTITION -t 8 sort_fanalysis_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_fa_mfc_l$LEVEL-p$PARTITION-t8.txt 

{ ls $IN_FILE* -la -ltr | grep \.mfc$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-mfc_size_l$LEVEL-p$PARTITION-t8.txt
{ ls sort_$IN_FILE* -la -ltr | grep \.mfc$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_mfc_size_l$LEVEL-p$PARTITION-t8.txt
{ ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.mfc$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_mfc_size_l$LEVEL-p$PARTITION-t8.txt

{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressD -v -$LEVEL -p $PARTITION -t 8 $IN_FILE.mfc ; } 2> $IN_FILE_SHORT_NAME-mfc_d_l$LEVEL-p$PARTITION-t8.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressD -v -$LEVEL -p $PARTITION -t 8 sort_$IN_FILE.mfc ; } 2>$IN_FILE_SHORT_NAME-sort_mfc_d_l$LEVEL-p$PARTITION-t8.txt
{ /bin/time -f "TIME\t%e\tMEM\t%M" ./MFCompressD -v -$LEVEL -p $PARTITION -t 8 sort_fanalysis_$IN_FILE.mfc ; } 2>$IN_FILE_SHORT_NAME-sort_fa_mfc_d_l$LEVEL-p$PARTITION-t8.txt

{ ls $IN_FILE* -la -ltr | grep \.mfc.d$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-mfc_d_size_l$LEVEL-p$PARTITION-t8.txt
{ ls sort_$IN_FILE* -la -ltr | grep \.mfc.d$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_mfc_d_size_l$LEVEL-p$PARTITION-t8.txt
{ ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.mfc.d$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_mfc_d_size_l$LEVEL-p$PARTITION-t8.txt

rm *mfc.d
  
}


function GZIP_COMPRESSION(){
  IN_FILE="$1";
  LEVEL="$2";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME
rm $IN_FILE.gz
rm sort_$IN_FILE.gz
rm sort_fanalysis_$IN_FILE.gz
{ /bin/time -f "TIME\t%e\tMEM\t%M"  gzip -k -$LEVEL $IN_FILE; } 2>$IN_FILE_SHORT_NAME-gzip_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M"  gzip -k -$LEVEL sort_$IN_FILE; } 2>$IN_FILE_SHORT_NAME-sort_gzip_l$LEVEL.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M"  gzip -k -$LEVEL sort_fanalysis_$IN_FILE ; } 2>$IN_FILE_SHORT_NAME-sort_fa_gzip_l$LEVEL.txt

{ ls $IN_FILE* -la -ltr | grep \.gz$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-gzip_size_l$LEVEL.txt  
{ ls sort_$IN_FILE* -la -ltr | grep \.gz$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_gzip_size_l$LEVEL.txt  
{ ls sort_$IN_FILE* -la -ltr | grep \.gz$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_gzip_size_l$LEVEL.txt  

{ /bin/time -f "TIME\t%e\tMEM\t%M" gunzip -c $IN_FILE.gz >$IN_FILE_SHORT_NAME-gunzip.fasta ; } 2>$IN_FILE_SHORT_NAME-gunzip_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M" gunzip -c sort_$IN_FILE.gz >sort_$IN_FILE_SHORT_NAME-gunzip.fasta ; } 2>$IN_FILE_SHORT_NAME-sort_gunzip_l$LEVEL.txt 
{ /bin/time -f "TIME\t%e\tMEM\t%M" gunzip -c sort_fanalysis_$IN_FILE.gz >sort_fanalysis_$IN_FILE_SHORT_NAME-gunzip.fasta ; } 2>$IN_FILE_SHORT_NAME-sort_fa_gunzip_l$LEVEL.txt 

{ ls $IN_FILE_SHORT_NAME* -la -ltr | grep \unzip.fasta$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-gunzip_size_l$LEVEL.txt 
{ ls sort_$IN_FILE_SHORT_NAME* -la -ltr | grep \unzip.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_gunzip_size_l$LEVEL.txt 
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME* -la -ltr | grep \unzip.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_gunzip_size_l$LEVEL.txt 

rm *unzip.fasta

}


function LZMA_COMPRESSION(){
  IN_FILE="$1";
  LEVEL="$2";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -$LEVEL -f -k $IN_FILE ; } 2> $IN_FILE_SHORT_NAME-lzma_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -$LEVEL -f -k sort_$IN_FILE ; } 2> $IN_FILE_SHORT_NAME-sort_lzma_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -$LEVEL -f -k sort_fanalysis_$IN_FILE ; } 2> $IN_FILE_SHORT_NAME-sort_fa_lzma_l$LEVEL.txt  

{ ls $IN_FILE* -la -ltr | grep \.lzma$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-lzma_size_l$LEVEL.txt 
{ ls sort_$IN_FILE* -la -ltr | grep \.lzma$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_lzma_size_l$LEVEL.txt 
{ ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.lzma$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_lzma_size_l$LEVEL.txt 

mv $IN_FILE.lzma $IN_FILE_SHORT_NAME-c_l.fasta.lzma
mv sort_$IN_FILE.lzma sort_$IN_FILE_SHORT_NAME-c_l.fasta.lzma
mv sort_fanalysis_$IN_FILE.lzma sort_fanalysis_$IN_FILE_SHORT_NAME-c_l.fasta.lzma

{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -f -k -d $IN_FILE_SHORT_NAME-c_l.fasta.lzma ; } 2>$IN_FILE_SHORT_NAME-lzma_d_l$LEVEL.txt   
{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -f -k -d sort_$IN_FILE_SHORT_NAME-c_l.fasta.lzma ; } 2>$IN_FILE_SHORT_NAME-sort_lzma_d_l$LEVEL.txt    
{ /bin/time -f "TIME\t%e\tMEM\t%M" lzma -f -k -d sort_fanalysis_$IN_FILE_SHORT_NAME-c_l.fasta.lzma ; } 2>$IN_FILE_SHORT_NAME-sort_fa_lzma_d_l$LEVEL.txt   

{ ls $IN_FILE_SHORT_NAME-c_l* -la -ltr | grep \.fasta$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-lzma_d_size_l$LEVEL.txt
{ ls sort_$IN_FILE_SHORT_NAME-c_l* -la -ltr | grep \.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_lzma_d_size_l$LEVEL.txt
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME-c_l* -la -ltr | grep \.fasta$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_lzma_d_size_l$LEVEL.txt

rm *-c_l.fasta
 
}
function BZIP2_COMPRESSION(){
  IN_FILE="$1";
  LEVEL="$2";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -$LEVEL -f -k $IN_FILE ; } 2> $IN_FILE_SHORT_NAME-bzip2_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -$LEVEL -f -k sort_$IN_FILE ; } 2> $IN_FILE_SHORT_NAME-sort_bzip2_l$LEVEL.txt  
{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -$LEVEL -f -k sort_fanalysis_$IN_FILE ; } 2> $IN_FILE_SHORT_NAME-sort_fa_bzip2_l$LEVEL.txt  

mv $IN_FILE.bz2 $IN_FILE_SHORT_NAME-c_b.fasta.bz2
mv sort_$IN_FILE.bz2 sort_$IN_FILE_SHORT_NAME-c_b.fasta.bz2
mv sort_fanalysis_$IN_FILE.bz2 sort_fanalysis_$IN_FILE_SHORT_NAME-c_b.fasta.bz2

{ ls $IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.bz2$ |awk '{print $5;}' ; } > $IN_FILE_SHORT_NAME-bzip2_size_l$LEVEL.txt  
{ ls sort_$IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.bz2$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_bzip2_size_l$LEVEL.txt  
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.bz2$ |awk '{print $5;}'; } > $IN_FILE_SHORT_NAME-sort_fa_bzip2_size_l$LEVEL.txt 

{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -f -k -d $IN_FILE_SHORT_NAME-c_b.fasta.bz2 ; } 2>$IN_FILE_SHORT_NAME-bzip2_d_l$LEVEL.txt   
{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -f -k -d sort_$IN_FILE_SHORT_NAME-c_b.fasta.bz2 ; } 2>$IN_FILE_SHORT_NAME-sort_bzip2_d_l$LEVEL.txt   
{ /bin/time -f "TIME\t%e\tMEM\t%M" bzip2 -f -k -d sort_fanalysis_$IN_FILE_SHORT_NAME-c_b.fasta.bz2 ; } 2>$IN_FILE_SHORT_NAME-sort_fa_bzip2_d_l$LEVEL.txt  

{ ls $IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.fasta$ |awk '{print $5;}' ; } >  $IN_FILE_SHORT_NAME-bzip2_d_size_l$LEVEL.txt 
{ ls sort_$IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.fasta$ |awk '{print $5;}'; } >  $IN_FILE_SHORT_NAME-sort_bzip2_d_size_l$LEVEL.txt 
{ ls sort_fanalysis_$IN_FILE_SHORT_NAME-c_b* -la -ltr | grep \.fasta$ |awk '{print $5;}'; } >  $IN_FILE_SHORT_NAME-sort_fa_bzip2_d_size_l$LEVEL.txt 

rm *-c_b.fasta

}


function CSV_BUILDER_JARVIS3(){

  IN_FILE="$1";
  LEVEL="$2";
  PARTITION="$3";
  PARTITION_MB="$4";
  SORTING_ALGORITHM="$5";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="JARVIS3_$INPUT_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
partition="$PARTITION"
bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_size_$PARTITION_MB-l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_$PARTITION_MB-l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_$PARTITION_MB-l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_$PARTITION_MB-l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_size_d_$PARTITION_MB-l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_d_$PARTITION_MB-l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_d_$PARTITION_MB-l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_jarvis3-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then

program="JARVIS3_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
partition="$PARTITION"
bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_size_$PARTITION_MB-l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_$PARTITION_MB-l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_$PARTITION_MB-l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_$PARTITION_MB-l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_d_$PARTITION_MB-l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_d_$PARTITION_MB-l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_d_$PARTITION_MB-l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_jarvis3-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="JARVIS3_$IN_FILE_SHORT_NAME"
level=$LEVEL
partition="$PARTITION"
bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_$PARTITION_MB-l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_$PARTITION_MB-l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-$PARTITION_MB-l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-$PARTITION_MB-l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-size_d_$PARTITION_MB-l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-d_$PARTITION_MB-l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-d_$PARTITION_MB-l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_jarvis3-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi

}

function CSV_BUILDER_NAF(){

IN_FILE="$1";
LEVEL="$2";
SORTING_ALGORITHM="$3";
  # $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
  # $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt
  #rm data_naf.csv

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="NAF_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_naf_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_naf_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_naf_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_unnaf_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_unnaf_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_unnaf_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_naf-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}


elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then  

program="NAF_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_naf_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_naf_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_naf_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_unnaf_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_unnaf_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_unnaf_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_naf-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else 

program="NAF_$IN_FILE_SHORT_NAME"
level=$LEVEL
bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-unnaf_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-unnaf_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-unnaf_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_naf-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi

}

function CSV_BUILDER_MBGC(){

IN_FILE="$1";
LEVEL="$2";
SORTING_ALGORITHM="$3";
  # $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
  # $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="MBGC_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_mbgc_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mbgc_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_mbgc_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_mbgc_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_mbgc_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_mbgc_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_mbgc_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mbgc-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}


elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then  

program="MBGC_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_mbgc_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mbgc_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_mbgc_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_mbgc_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_mbgc_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_mbgc_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_mbgc_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mbgc-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="MBGC_$IN_FILE_SHORT_NAME"
level=$LEVEL
bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mbgc_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mbgc_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-mbgc_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-mbgc_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mbgc_d_size-l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-mbgc_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-mbgc_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mbgc-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi

}

function CSV_BUILDER_MFCOMPRESS(){
  

  IN_FILE="$1";
  LEVEL="$2";
  PARTITION="$3";
  SORTING_ALGORITHM="$4";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="MFCOMPRESS_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
partition="$PARTITION"
#bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la sort_fanalysis_$IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_mfc_size_l$LEVEL-p$PARTITION-t8.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mfc_size_l$LEVEL-p$PARTITION-t8.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_mfc_l$LEVEL-p$PARTITION-t8.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_mfc_l$LEVEL-p$PARTITION-t8.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_mfc_d_size_l$LEVEL-p$PARTITION-t8.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_mfc_d_l$LEVEL-p$PARTITION-t8.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_mfc_d_l$LEVEL-p$PARTITION-t8.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mfcompress-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then

program="MFCOMPRESS_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
partition="$PARTITION"
#bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la sort_$IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_mfc_size_l$LEVEL-p$PARTITION-t8.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mfc_size_l$LEVEL-p$PARTITION-t8.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_mfc_l$LEVEL-p$PARTITION-t8.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_mfc_l$LEVEL-p$PARTITION-t8.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_mfc_d_size_l$LEVEL-p$PARTITION-t8.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_mfc_d_l$LEVEL-p$PARTITION-t8.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_mfc_d_l$LEVEL-p$PARTITION-t8.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mfcompress-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="MFCOMPRESS_$IN_FILE_SHORT_NAME"
level=$LEVEL
partition="$PARTITION"
#bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la $IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mfc_size_l$LEVEL-p$PARTITION-t8.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mfc_size_l$LEVEL-p$PARTITION-t8.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-mfc_l$LEVEL-p$PARTITION-t8.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-mfc_l$LEVEL-p$PARTITION-t8.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-mfc_d_size_l$LEVEL-p$PARTITION-t8.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-mfc_d_l$LEVEL-p$PARTITION-t8.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-mfc_d_l$LEVEL-p$PARTITION-t8.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $partition | tee partition_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_mfcompress-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$partition,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi

}
function CSV_BUILDER_GZIP(){

IN_FILE="$1";
LEVEL="$2";
SORTING_ALGORITHM="$3";
  # $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
  # $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME

if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="gzip_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
#bytes=$(ls sort_fanalysis_$IN_FILE_SHORT_NAME* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la sort_fanalysis_$IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_gzip_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-gzip_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_gzip_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_gzip_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_gunzip_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_gunzip_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_gunzip_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_gzip-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}


elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then  

program="gzip_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
#bytes=$(ls sort_$IN_FILE_SHORT_NAME* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la sort_$IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_gzip_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-gzip_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_gzip_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_gzip_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_gunzip_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_gunzip_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_gunzip_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 IN_FILE

file="data_gzip-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="gzip_$IN_FILE_SHORT_NAME"
level=$LEVEL
#bytes=$(ls $IN_FILE_SHORT_NAME* -la -ltr | grep \.fasta$ |awk '{print $5;}')
bytes=$(ls -la $IN_FILE_SHORT_NAME.fasta |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-gzip_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-gzip_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-gzip_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-gzip_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-gunzip_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-gunzip_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-gunzip_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_gzip-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi

}


function CSV_BUILDER_LZMA(){

IN_FILE="$1";
LEVEL="$2";
SORTING_ALGORITHM="$3";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME
  # $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
  # $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt


if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="lzma_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_lzma_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-lzma_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_lzma_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_lzma_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_lzma_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_lzma_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_lzma_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_lzma-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}


elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then  

program="lzma_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_lzma_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-lzma_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_lzma_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_lzma_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_lzma_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_lzma_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_lzma_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_lzma-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="lzma_$IN_FILE_SHORT_NAME"
level=$LEVEL
bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-lzma_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-lzma_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-lzma_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-lzma_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-lzma_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-lzma_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-lzma_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_lzma-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi


}



function CSV_BUILDER_BZIP2(){

IN_FILE="$1";
LEVEL="$2";
SORTING_ALGORITHM="$3";

  IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  echo $IN_FILE_SHORT_NAME
  # $IN_FILE_SHORT_NAME-naf_l$LEVEL.txt
  # $IN_FILE_SHORT_NAME-naf_size_l$LEVEL.txt


if [[ $SORTING_ALGORITHM == "fasta_analysis" ]]; then  

program="bzip2_$IN_FILE_SHORT_NAME-fasta_analysis"
level=$LEVEL
bytes=$(ls sort_fanalysis_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_bzip2_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-bzip2_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_fa_bzip2_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_bzip2_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_fa_bzip2_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_fa_bzip2_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_fa_bzip2_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_bzip2-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}


elif [[ $SORTING_ALGORITHM == "sortmf" ]]; then  

program="bzip2_$IN_FILE_SHORT_NAME-sortmf"
level=$LEVEL
bytes=$(ls sort_$IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_bzip2_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-bzip2_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-sort_bzip2_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_bzip2_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-sort_bzip2_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-sort_bzip2_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-sort_bzip2_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_bzip2-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

else

program="bzip2_$IN_FILE_SHORT_NAME"
level=$LEVEL
bytes=$(ls $IN_FILE* -la -ltr | grep \.fasta$ |awk '{print $5;}')
c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-bzip2_size_l$LEVEL.txt)
original_c_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-bzip2_size_l$LEVEL.txt)
bps_original=$(echo "scale=3; ($original_c_bytes * 8) / $bytes" | bc)
bps_final=$(echo "scale=3; ($c_bytes * 8) / $bytes" | bc)
#gain=$(echo "scale=3; ($c_bytes / $original_c_bytes)*100" | bc)
gain=$(echo "scale=3; (1-($c_bytes / $original_c_bytes))*100" | bc)
c_time=$(awk 'FNR ==1 {print $2}' $IN_FILE_SHORT_NAME-bzip2_l$LEVEL.txt)
c_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-bzip2_l$LEVEL.txt)
d_bytes=$(awk 'FNR ==1 {print $1}' $IN_FILE_SHORT_NAME-bzip2_d_size_l$LEVEL.txt)
d_time=$(awk 'FNR ==1 {print $2}'  $IN_FILE_SHORT_NAME-bzip2_d_l$LEVEL.txt)
d_mem=$(awk 'FNR ==1 {print $4}'  $IN_FILE_SHORT_NAME-bzip2_d_l$LEVEL.txt)
diff=0
if [ $bytes -eq $d_bytes ] 
 then
  diff=0
else
  diff=1
fi
run=0

printf $program | tee program_x
printf $bytes | tee bytes_x
printf $level | tee level_x
printf $c_bytes | tee c_bytes_x
printf $bps_original | tee bps_original_x
printf $bps_final | tee bps_final_x
printf $gain | tee gain_x
printf $c_time | tee c_time_x
printf $c_mem | tee c_mem_x
printf $d_time | tee d_time_x
printf $d_mem | tee d_mem_x
printf $diff | tee diff_x
printf $run | tee run_x
 

file="data_bzip2-$IN_FILE_SHORT_NAME.csv"

{
ed -s "$file" <<EOF
1
i
$program,$level,$bytes,$c_bytes,$bps_original,$bps_final,$gain,$c_time,$c_mem,$d_time,$d_mem,$diff,$run
.
wq
EOF
}

fi


}



function PLOT_JARVIS3(){
#rm *.csv
partitions_array=("10mb" "100mb" "1gb")
JARVIS_CSV=$1

  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
#echo "$(sort -t$',' -n -k9 $JARVIS_CSV.csv)" > "$JARVIS_CSV.csv"

#Build CSV for each partition
for ((i=0; i<${#JARVIS_CSV[@]}; i++)); do
 cat ${JARVIS_CSV[i]}.csv | grep -w "10MB" > ${JARVIS_CSV[i]}-10mb.csv
 cat ${JARVIS_CSV[i]}.csv| grep -w "100MB" > ${JARVIS_CSV[i]}-100mb.csv
 cat ${JARVIS_CSV[i]}.csv | grep -w "1GB" > ${JARVIS_CSV[i]}-1gb.csv

#Build CSV for each sorting algorithm
cat ${JARVIS_CSV[i]}.csv | grep -e "fasta_analysis" > ${JARVIS_CSV[i]}-fasta_analysis.csv
cat ${JARVIS_CSV[i]}.csv| grep -e "sortmf" > ${JARVIS_CSV[i]}-sortmf.csv
cat ${JARVIS_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" | grep -e "JARVIS3" > ${JARVIS_CSV[i]}-not_sorted.csv


#Build CSV combining partition with sorting algorithm
#JARVIS_CSV="data_jarvis3"
 cat ${JARVIS_CSV[i]}-10mb.csv | grep -e "sortmf" > ${JARVIS_CSV[i]}-10mb_sortmf.csv
  echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-10mb_sortmf.csv)" > "${JARVIS_CSV[i]}-10mb_sortmf.csv"
 cat ${JARVIS_CSV[i]}-100mb.csv | grep -e "sortmf" > ${JARVIS_CSV[i]}-100mb_sortmf.csv
  echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-100mb_sortmf.csv)" > "${JARVIS_CSV[i]}-100mb_sortmf.csv"
 cat ${JARVIS_CSV[i]}-1gb.csv | grep -e "sortmf" > ${JARVIS_CSV[i]}-1gb_sortmf.csv
  echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-1gb_sortmf.csv)" > "${JARVIS_CSV[i]}-1gb_sortmf.csv"
 cat ${JARVIS_CSV[i]}-10mb.csv | grep -e "fasta_analysis" > ${JARVIS_CSV[i]}-10mb_fasta_analysis.csv
  echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-10mb_fasta_analysis.csv)" > "${JARVIS_CSV[i]}-10mb_fasta_analysis.csv"
 cat ${JARVIS_CSV[i]}-100mb.csv | grep -e "fasta_analysis" > ${JARVIS_CSV[i]}-100mb_fasta_analysis.csv
   echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-100mb_fasta_analysis.csv)" > "${JARVIS_CSV[i]}-100mb_fasta_analysis.csv"
 cat ${JARVIS_CSV[i]}-1gb.csv | grep -e "fasta_analysis" > ${JARVIS_CSV[i]}-1gb_fasta_analysis.csv
  echo "$(sort -t$',' -n -k9 ${JARVIS_CSV[i]}-1gb_fasta_analysis.csv)" > "${JARVIS_CSV[i]}-1gb_fasta_analysis.csv"

done



 for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
  partition=${partitions_array[j]}
  plot_file="jarvis3-plot_${partitions_array[j]}.pdf"
  #echo $plot_file
  title="Compression Gains using JARVIS3.sh with partition ${partitions_array[j]}"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [-50:70]
        set xrange [80:4000]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot layout 1,2
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${JARVIS_CSV[0]}-${partitions_array[j]}-fasta_analysis.csv u 9:8 title "Synthetic Data" with linespoints linestyle count
        count=count + 1
        plot "${JARVIS_CSV[1]}-${partitions_array[j]}-fasta_analysis.csv" u 9:8 title "Real Data" with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done
done

#done

}

 function PLOT_NAF(){
   #rm *.csv
#partitions_array=("10mb" "100mb" "1gb")
NAF_CSV=$1

  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
#echo "$(sort -t$',' -k8 $NAF_CSV.csv)" > "$NAF_CSV.csv"

for ((i=0; i<${#NAF_CSV[@]}; i++)); do
#Build CSV for each sorting algorithm
cat ${NAF_CSV[i]}.csv | grep -e "fasta_analysis" > ${NAF_CSV[i]}-fasta_analysis.csv
echo "$(sort -t$',' -n -k 8 ${NAF_CSV[i]}-fasta_analysis.csv)" > "${NAF_CSV[i]}-fasta_analysis.csv"
cat ${NAF_CSV[i]}.csv| grep -e "sortmf" > ${NAF_CSV[i]}-sortmf.csv
echo "$(sort -t$',' -n -k 8 ${NAF_CSV[i]}-sortmf.csv)" > "${NAF_CSV[i]}-sortmf.csv"
cat ${NAF_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" > ${NAF_CSV[i]}-not_sorted.csv
echo "$(sort -t$',' -n -k 8 ${NAF_CSV[i]}-not_sorted.csv)" > "${NAF_CSV[i]}-not_sorted.csv"

done



 #for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
  #partition=${partitions_array[j]}
  plot_file="data_naf-plot.pdf"
  #echo $plot_file
  title="Compression Gains using naf"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [-20:100]
        set xrange [-10:1000]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot 
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${NAF_CSV[0]}-fasta_analysis.csv" u 8:7 title "Synthetic Data" with linespoints linestyle count
        count=count + 1
        #plot "${NAF_CSV[1]}-fasta_analysis.csv" u 8:7 title "Real Data" with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done


 }

 function PLOT_MBGC(){
   #MBGC_CSV="data_mbgc"
  MBGC_CSV=$1
  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
#echo "$(sort -t$',' -k 8 $MBGC_CSV.csv)" > "$MBGC_CSV.csv"

for ((i=0; i<${#MBGC_CSV[@]}; i++)); do
#Build CSV for each sorting algorithm
cat ${MBGC_CSV[i]}.csv | grep -e "fasta_analysis" > ${MBGC_CSV[i]}-fasta_analysis.csv
echo "$(sort -t$',' -k 8 ${MBGC_CSV[i]}-fasta_analysis.csv)" > "${MBGC_CSV[i]}-fasta_analysis.csv"
cat ${MBGC_CSV[i]}.csv| grep -e "sortmf" > ${MBGC_CSV[i]}-sortmf.csv
echo "$(sort -t$',' -k 8 ${MBGC_CSV[i]}-sortmf.csv)" > "${MBGC_CSV[i]}-sortmf.csv"
cat ${MBGC_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" > ${MBGC_CSV[i]}-not_sorted.csv
echo "$(sort -t$',' -k 8 ${MBGC_CSV[i]}-not_sorted.csv)" > "${MBGC_CSV[i]}-not_sorted.csv"


done
 #for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
 # partition=${partitions_array[j]}
  plot_file="data-plot_mbgc.pdf"
  #echo $plot_file
  title="Compression Gains using MBGC"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [12:14]
        set xrange [4.9:6.60]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${MBGC_CSV[0]}-fasta_analysis.csv" u 8:7 title "Synthetic Data"  with linespoints linestyle count
        count=count + 1
        plot "${MBGC_CSV[1]}-fasta_analysis.csv" u 8:7 title "Real Data"  with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done



 }

 function PLOT_MFCOMPRESS(){
  #rm *.csv
partitions_array=("1" "4" "8")
#MFCOMPRESS_CSV="data_mfcompress"
MFCOMPRESS_CSV=$1
  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
# echo "$(sort -t$',' -k 9 $MFCOMPRESS_CSV.csv)" > "$MFCOMPRESS_CSV.csv"

for ((i=0; i<${#MFCOMPRESS_CSV[@]}; i++)); do
#Build CSV for each partition
 cat ${MFCOMPRESS_CSV[i]}.csv | grep -w "1" | awk -F, '$3==1'  > ${MFCOMPRESS_CSV[i]}-1.csv
 cat ${MFCOMPRESS_CSV[i]}.csv| grep -w "4" | awk -F, '$3==1' > ${MFCOMPRESS_CSV[i]}-4.csv
 cat ${MFCOMPRESS_CSV[i]}.csv | grep -w "8" | awk -F, '$3==1' > ${MFCOMPRESS_CSV[i]}-8.csv

#Build CSV for each sorting algorithm
cat ${MFCOMPRESS_CSV[i]}.csv | grep -e "fasta_analysis" > ${MFCOMPRESS_CSV[i]}-fasta_analysis.csv
cat ${MFCOMPRESS_CSV[i]}.csv| grep -e "sortmf" > ${MFCOMPRESS_CSV[i]}-sortmf.csv
cat ${MFCOMPRESS_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" | grep -e "mfcompress" > ${MFCOMPRESS_CSV[i]}-not_sorted.csv


#Build CSV combining partition with sorting algorithm
#MFCOMPRESS_CSV="data_jarvis3"
 cat ${MFCOMPRESS_CSV[i]}-1.csv | grep -e "sortmf" > ${MFCOMPRESS_CSV[i]}-1_sortmf.csv
 echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-1_sortmf.csv)" > "${MFCOMPRESS_CSV[i]}-1_sortmf.csv"
 cat ${MFCOMPRESS_CSV[i]}-4.csv | grep -e "sortmf" > ${MFCOMPRESS_CSV[i]}-4_sortmf.csv
  echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-4_sortmf.csv)" > "${MFCOMPRESS_CSV[i]}-4_sortmf.csv"
 cat ${MFCOMPRESS_CSV[i]}-8.csv | grep -e "sortmf" > ${MFCOMPRESS_CSV[i]}-8_sortmf.csv
  echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-8_sortmf.csv)" > "${MFCOMPRESS_CSV[i]}-8_sortmf.csv"
 cat ${MFCOMPRESS_CSV[i]}-1.csv | grep -e "fasta_analysis" > ${MFCOMPRESS_CSV[i]}-1_fasta_analysis.csv
 echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-1_fasta_analysis.csv)" > "${MFCOMPRESS_CSV[i]}-1_fasta_analysis.csv"
 cat ${MFCOMPRESS_CSV[i]}-4.csv | grep -e "fasta_analysis" > ${MFCOMPRESS_CSV[i]}-4_fasta_analysis.csv
 echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-4_fasta_analysis.csv)" > "${MFCOMPRESS_CSV[i]}-4_fasta_analysis.csv"
 cat ${MFCOMPRESS_CSV[i]}-8.csv | grep -e "fasta_analysis" > ${MFCOMPRESS_CSV[i]}-8_fasta_analysis.csv
 echo "$(sort -t$',' -n -k 9 ${MFCOMPRESS_CSV[i]}-8_fasta_analysis.csv)" > "${MFCOMPRESS_CSV[i]}-8_fasta_analysis.csv"

done

 for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
  partition=${partitions_array[j]}
  plot_file="data-plot_mfcompress_${partitions_array[j]}.pdf"
  #echo $plot_file
  title="Compression Gains using MFCOMPRESS with partition ${partitions_array[j]}"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [-4:4]
        set xrange [0:500]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${MFCOMPRESS_CSV[0]}-${partitions_array[j]}_fasta_analysis.csv" u 9:8 title "Synthetic Data" with linespoints linestyle count
        count=count + 1
        plot "${MFCOMPRESS_CSV[1]}-${partitions_array[j]}_fasta_analysis.csv" u 9:8 title "Real Data"  with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done
done

 }

 function PLOT_GZIP(){
  #GZIP_CSV="data_gzip"
   GZIP_CSV=$1
  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
#echo "$(sort -t$',' -k 8 $GZIP_CSV.csv)" > "$GZIP_CSV.csv"

for ((i=0; i<${#GZIP_CSV[@]}; i++)); do
#Build CSV for each sorting algorithm
cat ${GZIP_CSV[i]}.csv | grep -e "fasta_analysis" > ${GZIP_CSV[i]}-fasta_analysis.csv
echo "$(sort -t$',' -n -k 8 ${GZIP_CSV[i]}-fasta_analysis.csv)" > "${GZIP_CSV[i]}-fasta_analysis.csv"
cat ${GZIP_CSV[i]}.csv| grep -e "sortmf" > ${GZIP_CSV[i]}-sortmf.csv
echo "$(sort -t$',' -n -k 8 ${GZIP_CSV[i]}-sortmf.csv)" > "${GZIP_CSV[i]}-sortmf.csv"
cat ${GZIP_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" > ${GZIP_CSV[i]}-not_sorted.csv
echo "$(sort -t$',' -n -k 8 ${GZIP_CSV[i]}-not_sorted.csv)" > "${GZIP_CSV[i]}-not_sorted.csv"
done

 #for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
 # partition=${partitions_array[j]}
  plot_file="data-plot_gzip.pdf"
  #echo $plot_file
  title="Compression Gains using GZIP"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [0:10]
        set xrange [0:800]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${GZIP_CSV[0]}-fasta_analysis.csv" u 8:7 title "Synthetic Data"  with linespoints linestyle count
        count=count + 1
        plot "${GZIP_CSV[1]}-fasta_analysis.csv" u 8:7 title "Real Data" with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done

 }

 function PLOT_LZMA(){
  #LZMA_CSV="data_lzma"
LZMA_CSV=$1
  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME


for ((i=0; i<${#LZMA_CSV[@]}; i++)); do
#Build CSV for each sorting algorithm
cat ${LZMA_CSV[i]}.csv | grep -e "fasta_analysis" > ${LZMA_CSV[i]}-fasta_analysis.csv
echo "$(sort -t$',' -n -k 8 ${LZMA_CSV[i]}-fasta_analysis.csv)" > "${LZMA_CSV[i]}-fasta_analysis.csv"
cat ${LZMA_CSV[i]}.csv| grep -e "sortmf" > ${LZMA_CSV[i]}-sortmf.csv
echo "$(sort -t$',' -n -k 8 ${LZMA_CSV[i]}-sortmf.csv)" > "${LZMA_CSV[i]}-sortmf.csv"
cat ${LZMA_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" > ${LZMA_CSV[i]}-not_sorted.csv
echo "$(sort -t$',' -n -k 8 ${LZMA_CSV[i]}-not_sorted.csv)" > "${LZMA_CSV[i]}-not_sorted.csv"
done


 #for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
 # partition=${partitions_array[j]}
  plot_file="data-plot_lzma.pdf"
  #echo $plot_file
  title="Compression Gains using LZMA"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [-40:100]
        set xrange [0:500]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${LZMA_CSV[0]}-fasta_analysis.csv" u 8:7 title "Synthetic Data" with linespoints linestyle count
        count=count + 1
        plot "${LZMA_CSV[1]}-fasta_analysis.csv" u 8:7 title "Real Data" with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done
 }

 function PLOT_BZIP2(){
  #BZIP2_CSV="data_bzip2"
  BZIP2_CSV=$1
  # IN_FILE_SHORT_NAME=$(ls -1 $IN_FILE | sed 's/.fasta//g')
  # echo $IN_FILE_SHORT_NAME
# echo "$(sort -t$',' -k 8 $BZIP2_CSV.csv)" > "$BZIP2_CSV.csv"

for ((i=0; i<${#BZIP2_CSV[@]}; i++)); do
#Build CSV for each sorting algorithm
cat ${BZIP2_CSV[i]}.csv | grep -e "fasta_analysis" > ${BZIP2_CSV[i]}-fasta_analysis.csv
echo "$(sort -t$',' -n -k 8 ${BZIP2_CSV[i]}-fasta_analysis.csv)" > "${BZIP2_CSV[i]}-fasta_analysis.csv"
cat ${BZIP2_CSV[i]}.csv| grep -e "sortmf" > ${BZIP2_CSV[i]}-sortmf.csv
echo "$(sort -t$',' -n -k 8 ${BZIP2_CSV[i]}-sortmf.csv)" > "${BZIP2_CSV[i]}-sortmf.csv"
cat ${BZIP2_CSV[i]}.csv | grep -v -e "fasta_analysis" | grep -v -e "sortmf" > ${BZIP2_CSV[i]}-not_sorted.csv
echo "$(sort -t$',' -n -k 8 ${BZIP2_CSV[i]}-not_sorted.csv)" > "${BZIP2_CSV[i]}-not_sorted.csv"

done

 #for j in "${!partitions_array[@]}"; do

  #for l in "${!sorting_method[@]}"; do
 # partition=${partitions_array[j]}
  plot_file="data-plot_bzip2.pdf"
  #echo $plot_file
  title="Compression Gains using BZIP2"
  #gain_x=$(awk -F "\"*,\"*" '{print $8}' data_level_${levels_array[j]}.csv) 
  #cat ${level_input_file[j]}
  #point=0
   #while (($point < ${#sorting_method_points_l1[@]})); do
   #C:/gnuplot/bin/gnuplot.exe << EOF
  gnuplot << EOF
        reset
        set terminal pdfcairo enhanced color font 'Verdade,12'
        set datafile separator "," 
        set title "$title"
        set output "$plot_file"
        set style line 101 lc rgb '#000000' lt 1 lw 2 
        set border 3 front ls 101
        set tics nomirror out scale 0.01
        set key fixed right top vertical Right noreverse noenhanced autotitle nobox
        set style histogram clustered gap 1 title textcolor lt -1
        set xtics border in scale 0,0 nomirror #rotate by -60  autojustify
        set yrange [10:80]
        set xrange [80:150]
        set xtics auto
        set ytics auto # set ytics auto
        set key top right
        set style line 1 lc rgb '#990099'  pt 1 ps 0.6  # circle
        set style line 2 lc rgb '#004C99'  pt 2 ps 0.6  # circle
        set style line 3 lc rgb '#CCCC00'  pt 3 ps 0.6  # circle
        #set style line 4 lc rgb '#CC0000' lt 2 dashtype '---' lw 4 pt 5 ps 0.4 # --- red
        set style line 4 lc rgb 'red'  pt 7 ps 0.6  # circle 
        set style line 5 lc rgb '#009900'  pt 5 ps 0.6  # circle
        set style line 6 lc rgb '#990000'  pt 6 ps 0.6  # circle
        set style line 7 lc rgb '#009999'  pt 4 ps 0.6  # circle
        set style line 8 lc rgb '#99004C'  pt 8 ps 0.6  # circle
        set style line 9 lc rgb '#CC6600'  pt 9 ps 0.6  # circle
        set style line 10 lc rgb '#322152' pt 10 ps 0.6  # circle    
        set style line 11 lc rgb '#425152' pt 11 ps 0.6  # circle    
        set grid
        set ylabel "Gain"
        set xlabel "Compression Time(s)"
        set multiplot
        count=12
      #  plot sorting_points u 7:8 w points ls count notitle
        plot "${BZIP2_CSV[0]}-fasta_analysis.csv" u 8:7 title "Synthetic Data" with linespoints linestyle count
        count=count + 1
        plot "${BZIP2_CSV[1]}-fasta_analysis.csv" u 8:7 title "Real Data" with linespoints linestyle count
        count=count + 1
         
EOF
   #point=$((point+1))
   #echo $point
 #done
 }
#--------MAIN---------------------------------------------------#

#testes com CVDB.fasta
#sorting CVDB.fasta file
#INPUT_FILE=$(GENERATE_ALCOR_FILE)
INPUT_FILE=("synthetic.fasta")


#INPUT_FILE_SHORT_NAME=$(ls -1 $INPUT_FILE | sed 's/.fasta//g')
#echo $INPUT_FILE_SHORT_NAME

#sorting files

#Tests performed by
#JARVIS3 
#rm *.txt
program=("" "fasta_analysis")
filename=("" "sort_fa")
sequence_type=("" "Alcor")

for ((m=0; m<${#INPUT_FILE[@]}; m++)); do

 #{  /bin/time -f "TIME\t%e\tMEM\t%M" ./FASTA_ANALY -sort=S ${INPUT_FILE[m]} sort_fanalysis_${INPUT_FILE[m]} 5 ;  } 2>>ordering_times.txt 
 #{  /bin/time -f "TIME\t%e\tMEM\t%M" ./sortmf ${INPUT_FILE[m]} sort_${INPUT_FILE[m]} ;  } 2>> sortmf_times.txt

# #NAF
 levels_array=("1" "8" "15" "22")
#levels_array=("1")
rm *.naf

 for ((i=0; i<${#levels_array[@]}; i++)); do
INPUT_FILE_SHORT_NAME=$(ls -1 ${INPUT_FILE[m]} | sed 's/.fasta//g')
NAF_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]} ;
echo "level" ${levels_array[i]} "completed"

done

#CSV_BUILDER NAF
rm data_naf-${INPUT_FILE[m]}.csv


for ((i=${#levels_array[@]}-1; i>=0; i--))
 do
   for ((j=${#program[@]}-1; j>=0; j--))
     do
      CSV_BUILDER_NAF ${INPUT_FILE[m]} ${levels_array[i]} ${program[j]}

   done
  done

  BUILD_CSV_HEADER_1 "naf" ${INPUT_FILE[m]} 
 #PLOT_NAF "data_naf-$INPUT_FILE_SHORT_NAME"

#  rm *naf.fasta;


# #MBGC
levels_array=("0" "1" "2" "3")
#levels_array=("0")

rm data_mbgc.csv
 rm *.mbgc

 for ((i=0; i<${#levels_array[@]}; i++)); do
  MBGC_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]};
 done

#CSV_BUILDER_MBGC
  for ((i=${#levels_array[@]}-1; i>=0; i--))
  do
   for ((j=${#program[@]}-1; j>=0; j--))
     do
      CSV_BUILDER_MBGC ${INPUT_FILE[m]} ${levels_array[i]} ${program[j]}
   done
  done


BUILD_CSV_HEADER_1 "mbgc" ${INPUT_FILE[m]} 
 # PLOT_MBGC "data_mbgc-$INPUT_FILE_SHORT_NAME"

# rm -d mbgc_decompress_*
# rm -d sort_mbgc_decompress_*
# rm -d sort_fa_mbgc_decompress_*



 rm "data_mfcompress.csv"
# #MFC
 levels_array=("0" "1" "2" "3")
 partitions_array=("1" "4" "8")
rm *.mfc
#levels_array=("0")
#partitions_array=("1")
#Levels for
for ((i=0; i<${#levels_array[@]}; i++)); do

#Partitions
  for((j=0; j<${#partitions_array[@]}; j++)); do
    MFCOMPRESS_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]} ${partitions_array[j]} ;
 done
done 

 #CSV_BUILDER_MFCOMPRESS
  for ((i=${#levels_array[@]}-1; i>=0; i--))
  do
  for ((j=${#partitions_array[@]}-1; j>=0; j--))
   do
    for ((k=${#program[@]}-1; k>=0; k--))
     do
      CSV_BUILDER_MFCOMPRESS ${INPUT_FILE[m]} ${levels_array[i]} ${partitions_array[j]} ${program[k]}

     done
    done
   done

   BUILD_CSV_HEADER_2 "mfcompress" ${INPUT_FILE[m]}
   # PLOT_MFCOMPRESS "data_mfcompress-$INPUT_FILE_SHORT_NAME"

  #rm *mfc.d

#General Use Compressors
levels_array=("1" "4" "7" "9")
#levels_array=("1")
#gzip
rm "data_gzip.csv"
rm *.gz
#execution mode
for((i=0; i<${#levels_array[@]}; i++)); do

  GZIP_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]};
done

  #CSV_BUILDER_GZIP
   #CSV_BUILDER_GZIP
   for ((i=${#levels_array[@]}-1; i>=0; i--))
   do
   for ((j=${#program[@]}-1; j>=0; j--))
     do
      CSV_BUILDER_GZIP ${INPUT_FILE[m]} ${levels_array[i]} ${program[j]}
   done
  done


BUILD_CSV_HEADER_1 "gzip" ${INPUT_FILE[m]}
# PLOT_GZIP "data_gzip-$INPUT_FILE_SHORT_NAME"


# #lzma
 levels_array=("1" "4" "7" "9")

rm "data_lzma.csv"
rm *.lzma
#levels_array=("1")
#program=("" "sortmf" "fasta_analysis")
#execution mode
for((i=0; i<${#levels_array[@]}; i++)); do

  LZMA_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]};
done

  #CSV_BUILDER_LZMA
   for ((i=${#levels_array[@]}-1; i>=0; i--))
   do
   for ((j=${#program[@]}-1; j>=0; j--))
     do
      CSV_BUILDER_LZMA ${INPUT_FILE[m]} ${levels_array[i]} ${program[j]}
   done
  done

  BUILD_CSV_HEADER_1 "lzma" ${INPUT_FILE[m]}
 # PLOT_LZMA "data_lzma-$INPUT_FILE_SHORT_NAME"

# bzip2
levels_array=("1" "4" "7" "9")
rm "data_bzip2.csv"
rm *.bz2
 #levels_array=("1")
#execution mode
for((i=0; i<${#levels_array[@]}; i++)); do

  BZIP2_COMPRESSION ${INPUT_FILE[m]} ${levels_array[i]};
done

#CSV_BUILDER_BZIP2
  for ((i=${#levels_array[@]}-1; i>=0; i--))
   do
   for ((j=${#program[@]}-1; j>=0; j--))
     do
      CSV_BUILDER_BZIP2 ${INPUT_FILE[m]} ${levels_array[i]} ${program[j]}
   done
  done

   BUILD_CSV_HEADER_1 "bzip2" ${INPUT_FILE[m]}
 # PLOT_BZIP2 "data_bzip2-$INPUT_FILE_SHORT_NAME"

#JARVIS3

levels_array=("1" "2" "5" "8" )
#levels_array=("15" "20" "25" "30")
partitions_array=("10MB" "100MB" "1GB")
partitions_in_mb=("10" "100" "1000")

rm *.tar
j=0

for ((i=0; i<${#levels_array[@]}; i++)); do
j=0
 while (($j < ${#partitions_array[@]} )); do
    JARVIS3_COMPRESSION $INPUT_FILE ${levels_array[i]} ${partitions_array[j]} ${partitions_in_mb[j]} ;

  j=$((j+1))
 done
done

rm data_jarvis3.csv
#CSV_BUILDER JARVIS3
for ((i=${#levels_array[@]}-1; i>=0; i--))
 do
  for ((j=${#partitions_array[@]}-1; j>=0; j--))
   do
    for ((k=${#program[@]}-1; k>=0; k--))
     do
      CSV_BUILDER_JARVIS3 ${INPUT_FILE[m]} ${levels_array[i]} ${partitions_array[j]} ${partitions_in_mb[j]} ${program[k]}

     done
    done
   done

      
     BUILD_CSV_HEADER_2 "jarvis3" ${INPUT_FILE[m]}
   #  PLOT_JARVIS3 "data_jarvis3-$INPUT_FILE_SHORT_NAME" $partitions_array
done
  # PLOT CREATION

    # PLOT_NAF $INPUT_FILE
    # PLOT_MBGC $INPUT_FILE
    # PLOT_MFCOMPRESS $INPUT_FILE 
    # PLOT_GZIP $INPUT_FILE
    # PLOT_LZMA $INPUT_FILE
    # PLOT_BZIP2 $INPUT_FILE
    # PLOT_JARVIS3 $INPUT_FILE
     

    #  mail -s " Att test" data_naf.csv tiagorfonseca@ua.pt 

    #  mutt -s "Subject" -a data_naf.csv -- tiagorfonseca@ua.pt < test-sort_fa_gunzip_l1.txt
#rm data.csv


  # IN_FILE="$1";
  # LEVEL="$2";
  # PARTITION="$3";
  # PARTITION_MB="$4";
  # SORTING_ALGORITHM="$5";

